### 代码

``` java
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        int diff = 0, mark = 1;
        for (int i = 0; i < array.length; i++)
            diff ^= array[i];
        for (int i = 0; i < 32; i++) {
            if ((mark & diff) != 0)
                break;
            mark <<= 1;
        }
        int a, b;
        a = b = 0;
        for (int i = 0; i < array.length; i++) {
            if ((array[i] & mark) != 0)
                a ^= array[i];
            else
                b ^= array[i];
        }
        num1[0] = a;
        num2[0] = b;
    }
}
```



### 思路

位运算，复杂度为O(n)。

* 第一步。
  * 将数组中的所有元素作异或（^）运算。即相异为1，相同为0。异或运算满足交换律，结合律。
  * 可以设置一个初值diff为0，然后就不需要从array[1]而直接从array[0]开始。这是因为任何数和0异或都是它自己，不变。
  * 这样一轮操作后，可得到两个只出现一次的数A和B（A≠B）异或的结果。因为相同的数异或都为0，那么最后只剩下A异或B的结果。
* 第二步。
  * 找出一个标记位，即diff中bit为1的哪一位。理论上说取任何一个bit为1的位都可以，但这里为了方便，取diff的第一个1（从低位到高位）作为标记位。标记位用mark来表示。
  * 设mark初值为1，然后从0到31迭代，第 i 次表示mark标记的是第 i 位（从0开始）。
    * 如果 diff & mark 不为0，说明diff的某一位为1，则已找到标记位，break。
    * 否则mark左移1位，继续查找。
* 第三步。
  * 将数组中的所有元素和mark作与运算（&）。这一步的目的是为了将数组分成两拨，一部分该标记位为1，另一部分该标记位为0。注意A和B必定在不同的两部分，因为如果A和B在同一拨，则说明它们的标记位相等，则异或结果标记位为0而不是1，矛盾。此外，相同的数必定也在同一拨，因为相同的数标记位是一定也相同的。如此一来，我们便可以将这个问题降级成一个比较简单的问题：一个数组中除了一个数组外，其余数字都出现了2次，请找出这个只出现了1次的数字。这个问题可以按第一步的异或做法进行，最后得到的结果就是该出现了1次的数。
  * 设两个数分别为A和B，初始化为0。
    * 如果array[i] & mark != 0，说明标记位为1，则A和同组的array[i]继续异或。
    * 否则，说明标记位为0，则B和同组的array[i]继续异或。
  * 最后即可得到问题答案A和B。



### 思路

* 异或的用途，主要用来检测相同（重复）的数
* 与的用途，主要用来提取某一位
* 第二步的神奇写法：mark = diff & -diff; （原理未知，可以直接提取第一个1作为标记位）