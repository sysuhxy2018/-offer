### 代码

``` java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        int n = sequence.length;
        if (n == 0)
            return false;
        return helper(sequence, 0, n - 1);
    }
    
    private boolean helper(int[] a, int l, int r) {
        if (l >= r)
            return true;
        
        int rv = a[r];
        int i = l, ind;
        while (i < r && a[i] < rv) {
            i++;
        }
        ind = i;
        while (i < r) {
            if (a[i] < rv)
                return false;
            i++;
        }
        return helper(a, l, ind - 1) && helper(a, ind, r - 1);
    }
}
```



### 思路

先简单介绍一下二叉搜索树的定义。就是任意结点的左子树（如果存在）的所有值必须严格小于该（根）结点；右子树（如果存在）的所有值必须严格大于该（根）结点。此外，左右子树都必须是二叉搜索树。所以二叉搜索树不存在两个值相同的结点。

而后序遍历最后一个元素总是根节点。所以根据二叉搜索树的性质和后序遍历的性质，我们可以将一个区间从左到右划分成左子树，右子树和根3部分。如下图所示：

![后序遍历](C:\Users\Xinyuan\Desktop\剑指offer\imgs\二叉搜索树的后序遍历序列.png)

* 先讨论特殊情况，即数组为空的情况，返回false。（不过二叉搜索树可以是空树，而空树的后序遍历结果自然是空的，理应返回true。是样例bug？）
* 实现一个区间递归方法helper，用 l 和 r 分别表示区间的下界和上界。
  * 特殊情况，l >= r时终止递归。即只剩一个结点时，可以直接还原出二叉树，且该树符合二叉搜索树的要求。所以直接返回true。
  * 一般情况，l < r时。维护一个遍历指针 i ，初始值为 l
    * 遍历除根外的剩余部分（i < r）直到 a[i] > a[r]。即遍历完了左子树，此时记录 i 的位置ind，ind即为右子树的起始位置。
    * 从ind开始继续遍历剩余部分（i < r）。如果途中发现a[i] < a[r]，则不符合右子树的性质，直接返回false。
    * 最后我们继续递归，检查左右子树是否都满足二叉搜索树的后序遍历。左子树的区间为[l, ind - 1]，而右子树的区间为[ind, r - 1]。



### 总结

这里简要总结一下数组区间递归的写法。

* 参数（如果有多个数组则有多组参数）
  * 数组本身
  * 表示下界的位置下标 l
  * 表示上界的位置下标 r
* 返回值，多视情况而定
* 内容
  * 终止情况。一般是l > r时终止，因为区间已经不成立了。l == r的情况也可以单独拿出来作为终止情况。不过，每种情况的返回值要具体分析。
  * 一般情况，l < r。需要将区间缩小来进行下一层递归（可能拆分成一个或者多个子区间）。

此外，二叉树部分的内容这里只是简单提及，其和其变种AVL树，红黑树等等这里不做过多探讨。