### 代码

``` java
public class Solution {
    public int Add(int num1,int num2) {
        int a = num1, b = num2;
        while (b != 0) {
            int tmp = a;
            a = a ^ b;
            b = (tmp & b) << 1;
        }
        return a;
    }
}
```



### 思路

既然不能使用四则运算符号，则很容易联想到使用位运算来做。

* 维护a，b两个变量，初始化为num1和num2。a，b代表求和操作的两个数。
* while，当b == 0时跳出循环。
  * 更新a = a ^ b
  * 更新b = (a & b) << 1
* b为0时，此时a就是结果，返回a。

下面说一下大概的原理。这个方法的核心是把每次相加的两个数拆分成不考虑进位下的和与进位两部分，然后这两部分再重复相加的操作，直到进位为0。简单来说，加法操作就是不断拆分更新，拆分更新......。比如a 和 b相加有：

* 不考虑进位时，a 和 b的和就是 a ^ b。因为0和1相加时为1，而1和1，0和0都是0。异或运算能很好地表达这一点，相异为1，相同为0。
* 进位。什么时候会出现进位呢？就是当a 和 b对应位置都是1的时候。这里我们使用&操作符，即a & b就能够标记出那些产生进位的位置，这些位置都是1（二进制的进位只能是1）。有了这个还不够，因为进位的最终目的是要加到下一位，所以我们将结果整体左移 1 位。

拆分后，实际上我们将问题转化为了这两部分再求和。所以可以用迭代或者递归来继续后面的操作。终止条件是当进位变为0时，此时可以直接返回结果，不需要再做额外的计算。

此外，还有一些注意事项：

* 为什么b一定会收敛到0？因为b每次都会有1个左移的操作，也就是说0的位数从低位到高位在不断增加......到最后肯定全部位都是0，即进位为0。
* 关于更新的写法，经常容易犯的一个错误是写成：a = a ^ b; b = (a & b) << 1; 更新a时没问题，但更新b时用到的a变成了更新后的a，而不是原来的a。所以更新操作时一定要多留心，观察已经更新的值对未更新的值有没有什么影响。如果有，就要将更新前的值先记录下来备用。



### 总结

这里我们总结一下&&和&操作符的区别，对于类似的||和|操作符同理。&&是逻辑操作符，它的两边必须都是布尔值的变量或者表达式。&是位运算符，它的两边必须都是整数，如byte, int, long等。

