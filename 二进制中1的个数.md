### 代码

``` java
public class Solution {
    public int NumberOf1(int n) {
        int a = n;
        int cnt = 0;
        while (a != 0) {
            if ((a & 1) == 1)
                cnt++;
            a = a >>> 1;
        }
        return cnt;
    }
}
```



### 思路

涉及到二进制的题目，往往用位运算解决。这题用位运算解决方法有很多种。这里代码演示的是从n的最低有效位开始，从右向左，不断提取出有效位直到提取完最高有效位。



### 总结

这里简单总结一下位运算的一些注意事项

* \>\>\>表示无符号右移。对于正数而言，>>>和>>没有区别；但对于负数，>>右移高位补1，>>>右移高位补0。
* 位运算的优先级都比较低，所以通常需要添加括号，如果写成a & 1 == 1这种相当于a & true，会出现数据类型不匹配的错误。
* 位运算中计算的数一般都包含正数或者负数，所以这里while (a != 0)不能习惯性写成while (a > 0)，否则负数根本不会进入循环。这里的终止条件是当a = 1时，右移1位后a就变为0了。
* &在位运算中一般用来提取或者保留数位。如提取第k位可以用n & (1 << k)。如果是判断第k位是不是1，则用(n & (1 << k)) != 0来判断，注意不能习惯性写成(n & (1 << k)) == 1这种。

最后补充介绍一个更高效率的思路，用n&(n-1)操作可以每次抹掉一个1(从低位到高位)。代码如下：

``` java
public class Solution {
    public int NumberOf1(int n) {
        int cnt = 0;
        while (n != 0) {
            cnt++;
            n = n & (n - 1);
        }
        return cnt;
    }
}
```

此外，也可用内置的方法Integer.bitCount(n)直接搞定。