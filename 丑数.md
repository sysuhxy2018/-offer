### 代码

``` java
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index <= 0)
            return 0;
        int a, b, c;
        a = b = c = 1;
        int[] dp = new int[index + 1];
        dp[1] = 1;
        for (int i = 2; i <= index; i++) {
            dp[i] = Math.min(Math.min(5 * dp[a], 3 * dp[b]), 2 * dp[c]);
            if (dp[i] == 5 * dp[a])
                a++;
            if (dp[i] == 3 * dp[b])
                b++;
            if (dp[i] == 2 * dp[c])
                c++;
        }
        return dp[index];
    }
}
```



### 思路

依旧是动态规划。

分析如下：每个新的丑数必定是由它前面的某一个丑数乘以 2 或者 3 或者 5 得来的，也就是说会有3个候选对象，我们设置为x，y和z。设 z < y < x，则z最小，需要乘5才可能超过当前的丑数，以此类推，y会乘3，x会乘2。

* 初始情况，只有第一个丑数 1 为候选对象，x = y = z = 1。
* 找出5\*z，3\*y和2\*x中最小的那个，即为下一个丑数。
* 比如找到的是3\*y，则候选对象y要进行更新，更新为y的后一个丑数。否则y不变的话，再乘以3的结果是无法超过得到的新丑数的。其他2种情况同理。
  * 特别注意可能存在多个候选对象都能得到下一个丑数的情况，如3\*y == 2\*x的情况，这样的话y和x都要更新。也就是说这里要写成**3个独立的if结构**，而不是3选1的if-else结构。

这里我们用dp[n]表示第n个丑数，维护3个下标a，b和c，表示候选对象是第几个丑数。然后dp迭代更新，最后返回dp[n]即可。时间复杂度只需要O(n)。



### 总结

注意体会dp和递归的思想，都是通过解决并整合子问题来解决原问题。

