### 代码

``` java
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if (n == 0 || m == 0)
            return -1;
        if (n == 1)
            return 0;
        return (LastRemaining_Solution(n - 1, m) + m) % n;
    }
}
```



### 思路

这类问题称为”约瑟夫环“问题，可以用数学推理解决。问题的一般形式是：一共有n个人围成一圈，从第1个人开始数数，数到第k个人时，这个人出圈。然后从这个人的下一个人开始重新数数......一直重复这样的操作，直到最后只剩下1个人，求这个人的编号。注意这里的k是从开始计数到终止计数所经过的人数，比如每次从3开始报数，报到7的人出圈，则k = 7 - 3 + 1 = 5。

推导公式分两种：编号从0开始的，和编号从1开始的。通常按编号为0处理。

```java
f(n, k) = (f(n - 1, k) + k) % n, f(1, k) = 0;	//0下标开始
f(n, k) = (f(n - 1, k) + k - 1) % n + 1, f(1, k) = 1;	//1下标开始
```

具体的原理这里不细说了，大致是用数学归纳法找出一个问题和子问题间的一种规律 。最基本的情况就是n = 1时，此时这一个人就直接得到答案，即下标为0。

另外注意特殊情况的判断，当n = 0时，根本没人，也就不存在最后剩下的人；当k = 0时，根本不会有人出圈，所以不存在只剩最后一人的情况（尽管n = 1时就只有1个人，但我们统一处理为无效情况）。这两种情况都属于无效情况，所以直接返回-1。



### 总结

当然，本题最直观易懂的做法是直接模拟这种操作。我们其实没必要自己去构造一个循环链表，然后一个个去计数模拟。这样做十分麻烦，而且会使得时间复杂度变为O(n * m)。实际上，用线性表去模拟整个操作就好了，而且不用每次一个步长一个步长去计数，找到一个位置后可以直接跳到下一个位置，这样总的时间复杂度还是O(n)。

``` java
import java.util.*;

public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if (n == 0 || m == 0)
            return -1;
        LinkedList<Integer> circle = new LinkedList<>();
        for (int i = 0; i < n; i++)
            circle.add(i);
        int i = 0;
        while (circle.size() > 1) {
            int ind = (i + (m - 1)) % circle.size();
            circle.remove(ind);
            i = ind;
        }
        return circle.get(0);
    }
}
```

* 先初始化整个表，将0~n-1的元素放到表中，每个元素代表一个人的编号。
* 初始化 i = 0，因为是从第一个人开始计数的。i 表示每次开始的那个人的**下标（不是编号!)**
* 当表中元素数量 == 1时跳出循环
  * 从 i 开始的话，下一个要出圈的人下标是 (i + (m - 1)) % n。为了防止越界，所以要% n，但注意这里的n不是开始的n，应该是整个线性表的大小。因为大小总是在变动的，直接% circle.size()。
  * 得到出圈的人的下标ind后，直接remove掉下标为ind的元素。这时，原来ind的下一位就顺位变成了ind。那么我们直接从新的ind位开始就行了，即更新 i = ind。
* 最后表里只剩下一个元素了，返回该元素的值（编号）即可。

个人觉得这个方法是最佳的方法，避免死板地套用公式，而且公式的背景限制也很多，不灵活。这个方法有几个优点：

* 可以很直观地得到每一轮出圈的人的编号。
* 可以指定开始计数的位置，如要从第k个人开始计数，则初始化 i = k。
* 可以适应更复杂的模拟操作等。

最后是一些注意事项：

* 这里线性表选用ArrayList也是可以的，但考虑到remove的效率，还是LinkedList好一点。Java里的LinkedList是可以直接获取下标并操作该下标的，所以相较于普通的链表，才不需要一个个结点去遍历。相当于结合了传统链表和数组的优点吧。
* list的remove方法有两种重载，一种是remove(E obj)，直接移除对应对象；还有一种是remove(int i)，直接移除下标为 i 的对象。如果E恰好又是Integer的话，很容易引起歧义。不过Java还是会遵循最佳匹配的原则，所以remove(6)表示remove掉下标为6的元素，而如果想remove值为6的元素，则需要转换成Integer，即remove(new Integer(6))。这里的话我们是要remove下标，所以直接用就可以了。
  * 一般除了线性表外，其他的数据结构似乎都不会有下标表示，所以remove直接就表示remove掉相应的值而不存在歧义的问题。

